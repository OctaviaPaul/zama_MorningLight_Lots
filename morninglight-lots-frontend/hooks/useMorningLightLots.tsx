"use client";

import { useState, useCallback, useEffect } from "react";
import { ethers } from "ethers";
import { useWallet } from "./useWallet";
import { useFhevm } from "../fhevm/useFhevm";
import { FhevmDecryptionSignature } from "../fhevm/FhevmDecryptionSignature";
import fortunesData from "../data/fortunes.json";
import type { FortuneRecord, FortuneContent, FortunesData } from "../types/fortune";

// Import ABI (will be generated by genabi.mjs)
// If ABI files don't exist, app will show "contract not deployed" message
import { MorningLightLotsABI } from "../abi/MorningLightLotsABI";
import { MorningLightLotsAddresses } from "../abi/MorningLightLotsAddresses";

const fortunes: FortunesData = fortunesData as FortunesData;

export function useMorningLightLots() {
  const { account, chainId, provider } = useWallet();
  const { fhevmInstance } = useFhevm();

  const [contract, setContract] = useState<ethers.Contract | null>(null);
  const [isDrawing, setIsDrawing] = useState(false);
  const [isDecrypting, setIsDecrypting] = useState(false);
  const [canDraw, setCanDraw] = useState(false);
  const [todayDrawCount, setTodayDrawCount] = useState(0);
  const [remainingCooldown, setRemainingCooldown] = useState(0);
  const [fortuneCount, setFortuneCount] = useState(0);
  const [error, setError] = useState<string | null>(null);

  // Initialize contract
  useEffect(() => {
    if (!provider || !chainId || !account) {
      setContract(null);
      return;
    }

    const contractAddress = MorningLightLotsAddresses[chainId as keyof typeof MorningLightLotsAddresses];
    if (!contractAddress || contractAddress === "0x0000000000000000000000000000000000000000") {
      console.warn("Contract not deployed on this network");
      setContract(null);
      return;
    }

    async function initContract() {
      try {
        const ethersProvider = new ethers.BrowserProvider(provider);
        const signer = await ethersProvider.getSigner();
        const contractInstance = new ethers.Contract(
          contractAddress,
          MorningLightLotsABI,
          signer
        );
        setContract(contractInstance as any);
      } catch (err) {
        console.error("Failed to initialize contract:", err);
        setContract(null);
      }
    }

    initContract();
  }, [provider, chainId, account]);

  // Fetch status
  const fetchStatus = useCallback(async () => {
    if (!contract) return;

    try {
      const [canDrawResult, todayCount, remaining, count] = await Promise.all([
        contract.canDrawNow(),
        contract.getTodayDrawCount(),
        contract.getRemainingCooldown(),
        contract.getMyFortuneCount(),
      ]);

      setCanDraw(canDrawResult);
      setTodayDrawCount(Number(todayCount));
      setRemainingCooldown(Number(remaining));
      setFortuneCount(Number(count));
    } catch (err: any) {
      console.error("Failed to fetch status:", err);
    }
  }, [contract]);

  useEffect(() => {
    fetchStatus();
    const interval = setInterval(fetchStatus, 5000);
    return () => clearInterval(interval);
  }, [fetchStatus]);

  // Draw fortune
  const drawFortune = useCallback(async () => {
    if (!contract || !account) {
      throw new Error("Contract or account not available");
    }

    setIsDrawing(true);
    setError(null);

    try {
      const tx = await contract.drawFortune();
      const receipt = await tx.wait();

      // Extract drawId from event
      const event = receipt.logs?.find((log: any) => {
        try {
          const parsed = contract.interface.parseLog(log);
          return parsed?.name === "FortuneDrawn";
        } catch {
          return false;
        }
      });

      let drawId = 0;
      if (event) {
        const parsed = contract.interface.parseLog(event);
        drawId = Number(parsed?.args?.drawId || 0);
      }

      console.log("â³ Waiting for authorization to propagate in Mock mode...");
      
      // Clear cached signature to force regeneration with new authorization
      if (account) {
        const contractAddr = await contract.getAddress();
        FhevmDecryptionSignature.clearFromStorage(account, [contractAddr]);
      }
      
      // Wait for authorization to propagate
      await new Promise(resolve => setTimeout(resolve, 1000));
      
      await fetchStatus();

      return drawId;
    } catch (err: any) {
      console.error("Failed to draw fortune:", err);
      const message = err.reason || err.message || "Failed to draw fortune";
      setError(message);
      throw new Error(message);
    } finally {
      setIsDrawing(false);
    }
  }, [contract, account, fetchStatus]);

  // Decrypt fortune
  const decryptFortune = useCallback(
    async (fortuneIndex: number): Promise<FortuneContent> => {
      if (!contract || !account || !fhevmInstance || !provider) {
        throw new Error("Contract, account, provider, or FHEVM instance not available");
      }

      setIsDecrypting(true);
      setError(null);

      try {
        // Get encrypted fortune from contract
        // Use staticCall because getMyFortune is not a view function (has FHE.allow)
        const encryptedFortune = await contract.getMyFortune.staticCall(fortuneIndex);
        console.log("ðŸ“¦ Encrypted fortune (handle):", encryptedFortune);
        console.log("ðŸ“¦ Handle type:", typeof encryptedFortune);

        const contractAddress = await contract.getAddress();
        console.log("ðŸ“ Contract address:", contractAddress);
        
        // Get signer from provider
        const ethersProvider = new ethers.BrowserProvider(provider);
        const signer = await ethersProvider.getSigner();
        
        // Load or create decryption signature (cached in localStorage)
        console.log("ðŸ” Getting decryption signature...");
        const sig = await FhevmDecryptionSignature.loadOrSign(
          fhevmInstance,
          [contractAddress],
          signer
        );

        if (!sig) {
          throw new Error("Unable to create decryption signature");
        }

        // Decrypt using userDecrypt (works in both Mock and Relayer modes)
        console.log("ðŸ”“ Calling userDecrypt...");
        const decryptedValues = await fhevmInstance.userDecrypt(
          [{ handle: encryptedFortune, contractAddress }],
          sig.privateKey,
          sig.publicKey,
          sig.signature,
          sig.contractAddresses,
          sig.userAddress,
          sig.startTimestamp,
          sig.durationDays
        );

        console.log("âœ¨ Decrypted values:", decryptedValues);
        const fortuneNumber = Number(decryptedValues[encryptedFortune]);

        // Get fortune content from local data
        const fortuneContent = fortunes[fortuneNumber.toString()];
        if (!fortuneContent) {
          throw new Error(`Fortune ${fortuneNumber} not found`);
        }

        // Cache the decrypted fortune
        const cacheKey = `fortune_${account}_${fortuneIndex}`;
        localStorage.setItem(cacheKey, JSON.stringify(fortuneContent));

        return fortuneContent;
      } catch (err: any) {
        console.error("Failed to decrypt fortune:", err);
        const message = err.reason || err.message || "Failed to decrypt fortune";
        setError(message);
        throw new Error(message);
      } finally {
        setIsDecrypting(false);
      }
    },
    [contract, account, fhevmInstance, provider]
  );

  // Get cached fortune
  const getCachedFortune = useCallback(
    (fortuneIndex: number): FortuneContent | null => {
      if (!account) return null;

      const cacheKey = `fortune_${account}_${fortuneIndex}`;
      const cached = localStorage.getItem(cacheKey);
      if (cached) {
        try {
          return JSON.parse(cached);
        } catch {
          return null;
        }
      }
      return null;
    },
    [account]
  );

  // Get all fortune records (from events)
  const getFortuneRecords = useCallback(async (): Promise<FortuneRecord[]> => {
    if (!contract || !account) return [];

    try {
      const filter = contract.filters.FortuneDrawn(account);
      const events = await contract.queryFilter(filter);

      const records: FortuneRecord[] = [];

      for (let i = 0; i < events.length; i++) {
        const event = events[i];
        // Type guard for EventLog
        if (!("args" in event)) continue;
        const args = event.args;

        const timestamp = Number(args.timestamp);
        const drawId = args.drawId.toString();
        const cooldownEndTime = timestamp + 5; // 5 seconds cooldown (matches contract)
        const now = Math.floor(Date.now() / 1000);

        let status: "cooling" | "ready" | "decrypted" = "ready";
        if (now < cooldownEndTime) {
          status = "cooling";
        }

        const cached = getCachedFortune(i);
        if (cached) {
          status = "decrypted";
        }

        records.push({
          drawId,
          user: account,
          timestamp,
          handle: "", // Not exposed in event
          fortuneNumber: cached?.number || null,
          status,
          cooldownEndTime,
          decryptedAt: cached ? timestamp : null,
          fortuneContent: cached || undefined,
        });
      }

      return records.reverse(); // Newest first
    } catch (err) {
      console.error("Failed to get fortune records:", err);
      return [];
    }
  }, [contract, account, getCachedFortune]);

  return {
    contract,
    canDraw,
    todayDrawCount,
    remainingCooldown,
    fortuneCount,
    isDrawing,
    isDecrypting,
    error,
    drawFortune,
    decryptFortune,
    getCachedFortune,
    getFortuneRecords,
    fetchStatus,
  };
}

